(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{57:function(t,v,l){"use strict";l.r(v);var _=l(0),s=Object(_.a)({},(function(){var t=this,v=t.$createElement,l=t._self._c||v;return l("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[l("div",{staticClass:"custom-block warning"},[l("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),l("p",[t._v("部署章节仅用于交接, 不提供示例代码")])]),t._v(" "),l("p",[t._v("IM项目的部署还是比较简单的, 不过为了减少重复性的工作, 我专门写了一个用于部署的脚本, 用于将打包好的项目放入指定文件夹. 脚本的路径为: im/build/deploy.ts"),l("br"),t._v("\n另外, 还有一些注意事项需要特别说明下")]),t._v(" "),l("h2",{attrs:{id:"注意事项"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#注意事项"}},[t._v("#")]),t._v(" 注意事项")]),t._v(" "),l("ol",[l("li",[l("p",[t._v("目录")]),t._v(" "),l("ul",[l("li",[t._v("cdnUrl 用于放置js, css等静态资源的目录")]),t._v(" "),l("li",[t._v("webURL 用于放置入口文件的目录")])])]),t._v(" "),l("li",[l("p",[t._v("publicPath路径替换为变量"),l("br"),t._v("\n为什么在部署时, 要将生成后的publicPath路径替换为变量呢? 原因如下:")]),t._v(" "),l("ul",[l("li",[t._v("部署后静态资源和入口文件"),l("strong",[t._v("不在同一个子域名下")]),t._v(", 因此配置publicPath时, "),l("strong",[t._v("生产模式不能使用相对路径")])]),t._v(" "),l("li",[t._v("后端有 开发/测试/线上 三个不同环境, "),l("strong",[t._v("写死绝对路径也是行不通的")]),t._v(", 因此需要"),l("strong",[t._v("写成一个变量")])]),t._v(" "),l("li",[t._v("vue的publicPath在打包后, 生成的"),l("strong",[t._v("是一个字符串, 不能为变量(?)")])])]),t._v(" "),l("p",[t._v("由于以上原因, 所以在部署时, 需要将publicPath路径替换为变量")])]),t._v(" "),l("li",[l("p",[t._v("部署失败\n一般部署失败可能是:")]),t._v(" "),l("ul",[l("li",[t._v("目录配置不对(目录不存在)")]),t._v(" "),l("li",[t._v("每次部署前会文件比对, 上一次部署时修改publicPath路径后, js文件的hash值改变, 本次部署会将其删除. 解决办法是再部署一遍")])])])])])}),[],!1,null,null,null);v.default=s.exports}}]);